//
//  JJiOSInterview03.m
//  JJ_Class_25_2018_iOS面试题系列
//
//  Created by Jay on 2018/4/19.
//  Copyright © 2018年 com.xiaoniu88.XNOnline. All rights reserved.
//

#import "JJiOSInterview03.h"


/**
 一、KVO内部实现原理
 KVO是基于runtime机制实现的
 当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类,在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的 setter 方法实现真正的通知机制（Person->NSKVONotifying_Person）
 二 、 是 否 可 以 把 比 较 耗 时 的 操 作 放 在NSNotificationCenter中
 如果在异步线程发的通知，那么可以执行比较耗时的操作；
 如果在主线程发的通知，那么就不可以执行比较耗时的操作
 
 三、Foundation对象与 Core Foundation对象有什么区别
 1>Foundation对象是OC的，Core Foundation对象是C对象
 2> 数据类型之间的转换
 · ARC:__bridge_retained、__bridge_transfer
 · 非ARC: __bridge
 
 四、不用中间变量,用两种方法交换 A和 B的值
 A=A + B
 B=A - B
 A=A - B
 或者
 
 A=A^B;
 B=A^B;
 A=A^B;
 五、简单描述下对单利模式设计的理解？
 节省内存资源，一个应用就一个对象。
 
 六、什么是动态，举例说明
 在程序运行过程才执行的操作
 
 七、runtime实现的机制是什么,怎么用，一般用于干嘛. 你还能记得你所使用的相关的头文件或者某些方法的名称吗？
 运行时机制，runtime库里面包含了跟类、成员变量、方法相关的API，比如获取类里面的所有成员变量，为类动态添加成员变量，动态改变类的方法实现，为类动态添加新的方法等 需要导入<objc/message.h><objc/runtime.h> runtime，运行时机制，它是一套C语言库。 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西，比如类转成了runtime库里面的结构体等数据类型，方法转成了runtime库里面的C语言函数，平时调方法都是转成了objc_msgSend函数（所以说OC有个消息发送机制）因此，可以说runtime是OC的底层实现，是OC的幕后执行者。有了runtime库，能做什么事情呢？runtime库里面包含了跟类、成员变量、方法相关的API，比如获取类里面的所有成员变量，为类动态添加成员变量，动态改变类的方法实现，为类动态添加新的方法等。因此，有了runtime，想怎么改就怎么改
 
 八、是否使用 Core Text或者 Core Image等？如果使用过，请谈谈你使用 CoreText或者 CoreImage的体验。
 CoreText
 
 随意修改文本的样式
 图文混排(纯C语言)
 国外:Niumb
 Core Image(滤镜处理)
 
 能调节图片的各种属性(对比度, 色温, 色差等)
 九、NSNotification和 KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array)来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？（虽然 protocol和 delegate这种东西面试已经面烂了…）
 NSNotification是通知模式在iOS的实现，KVO的全称是键值观察(Key-value observing),其是基于KVC（key-value coding）的，KVC是一个通过属性名访问属性变量的机制。例如将Module层的变化，通知到多个Controller对象时，可以使用NSNotification；如果是只需要观察某个对象的某个属性，可以使用KVO。
 对于委托模式，在设计模式中是对象适配器模式，其是delegate是指向某个对象的，这是一对一的关系，而在通知模式中，往往是一对多的关系。委托模式，从技术上可以现在改变delegate指向的对象，但不建议这样做，会让人迷惑，如果一个delegate对象不断改变，指向不同的对象。
 
 十、Block内部的实现原理
 Objective-C是对C语言的扩展，block的实现是基于指针和函数指针
 
 iOS - 揭露Block的内部实现原理
 
 十一、使用 protocol时，声明一组可选择实现与否的函数，需要在声明的前一行加上
 @required
 
 十二、怎样防止指针的越界使用问题?
 必须让指针指向一个有效的内存地址, 1、防止数组越界2、防止向一块内存中拷贝过多的内容3、防止使用空指针4、防止改变 const 修改的指针5、防止改变指向静态存储区的内容6、防止两次释放一个指针7、防止使用野指针.
 
 十三、谈谈 webView的作用
 webview与运维成本低， 更新几乎不依赖App的版本
 
 十四、What is purpose of delegates? 代理的作用？
 代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。 另外一点，代理可以理解为 java中的回调监听机制的一种类似
 
 十五、What are mutable and immutable types in Objective C? obc中可修改和不可以修改类型。
 可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。比如 NSArray 和 NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。
 
 十六、When we call objective c is runtimelanguage what does it mean? 我们说的 obc是动态运行时语言是什么意思？
 多态。 主要是将数据类型的确定由编译时，推迟到了运行时。这个问题其实浅涉及到两个概念，运行时和多态。简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。 多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat; 那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat，但是调用是我们只需调用各自的 eat 方法。也就是不同的对象以自己的方式响应了相同的消息（响应了 eat 这个选择器）。 因此也可以说，运行时机制是多态的基础.
 
 十七、Polymorphism？关于多态性
 多态，子类指针可以赋值给父类。父类指针指向子类指针。
 多态是具有表现多种形态的能力的特征，是为了避免在父类里大量重载引起代码臃肿且难于维护。继承是子类使用父类的方法，而多态则是父类使用子类中重写父类的方法
 
 十八条、obj-c有私有方法么?私有变量呢?
 在 Objective-C 中没有私有方法，只有静态方法和实例方法。但是可以用@private修饰私有变量。
 
 十九条、什么是键-值,键路径是什么？
 模型的性质是通过一个简单的键（通常是个字符串）来指定的。视图和控制器通过键来查找相应的属性值。在一个给定的实体中，同一个属性的所有值具有相同的数据类型。键-值编码技术用于进行这样的查找—它是一种间接访问对象属性的机制。键路径是一个由用点作分隔符的键组成的字符串，用于指定一个连接在一起的对象性质序列。第一个键的性质是由先前的性质决定的，接下来每个键的值也是相对于其前面的性质。键路径使您可以以独立于模型实现的方式指定相关对象的性质。通过键路径，您可以指定对象图中的一个任意深度的路径，使其指向相关对象的特定属性.
 
 二十、c和 obj-c如何混用
 1）obj-c 的编译器处理后缀为 m 的文件时，可以识别 obj-c 和 c 的代码，处理 mm文件可以识别 obj-c,c,c++代码，但 cpp 文件必须只能用 c/c++代码，而且 cpp 文件include 的头文件中，也不能出现 obj- c 的代码，因为 cpp 只是 cpp 2) 在 mm 文件中混用 cpp 直接使用即可，所以 obj-c 混 cpp 不是问题 3）在 cpp 中混用 obj- c其实就是使用 obj-c 编写的模块是我们想要的。 如果模块以类实现，那么要按照cpp class 的标准写类的定义，头文件中不能出现 obj-c 的东西，包括#import cocoa的。实现文件中，即类的实现代码中可以使用 obj-c 的东西，可以 import,只是后缀是 mm。 如果模块以函数实现，那么头文件要按 c 的格式声明函数，实现文件中，c++函数内部可以用 obj-c，但后缀还是 mm 或 m。 总结：只要 cpp 文件和 cpp include 的文件中不包含 obj-c 的东西就可以用了，cpp 混用 obj-c 的关键是使用接口，而不能直接使用实现代码，实际上 cpp 混用的是 obj-c 编译后的 o 文件，这个东西其实是无差别的，所以可以用。obj-c 的编译器支持 cpp.
 
 二十一、浅拷贝和深拷贝区别是什么
 在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误
 
 二十二、Object-C有多继承吗？没有的话用什么代替？cocoa 中所有的类都是 NSObject 的子类
 Object-C没有多继承
 多继承在这里是用 protocol 委托代理 来实现的。不用去考虑繁琐的多继承 ,虚基类的概念.ood 的多态特性 在 obj-c 中通过委托来实现.
 
 二十二、在 Xcode中，需要编译混合 Objective-C和 C++的源码文件，需要将文件格式的后缀改为()
 .mm
 
 二十三、在 Objective-C声明一个类所要用到的编译指令是 （）
 @interface someClass
 
 二十四、使用 Xcode创建工程时，支持同时创建的版本管理库是
 git
 

 */
@implementation JJiOSInterview03

@end
